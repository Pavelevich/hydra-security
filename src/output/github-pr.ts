import { execFile } from "node:child_process";
import type { PatchResult, ScanResult } from "../types";

export interface GitHubPrOptions {
  repoPath: string;
  baseBranch?: string;
  branchPrefix?: string;
  dryRun?: boolean;
}

interface ExecOutput {
  stdout: string;
  stderr: string;
  exitCode: number;
}

function run(command: string, args: string[], cwd: string, timeoutMs = 30_000): Promise<ExecOutput> {
  return new Promise((resolve, reject) => {
    execFile(command, args, { cwd, timeout: timeoutMs, maxBuffer: 5 * 1024 * 1024 }, (error, stdout, stderr) => {
      const exitCode = error && "code" in error ? (error.code as number) ?? 1 : 0;
      resolve({ stdout: stdout ?? "", stderr: stderr ?? "", exitCode });
    });
  });
}

function buildPrTitle(scanResult: ScanResult, patchResults: PatchResult[]): string {
  const verified = patchResults.filter((r) => r.status === "patched_and_verified").length;
  const total = patchResults.length;
  const findingCount = scanResult.findings.length;
  return `[Hydra] ${findingCount} finding${findingCount === 1 ? "" : "s"}, ${verified}/${total} patch${total === 1 ? "" : "es"} verified`;
}

function buildPrBody(scanResult: ScanResult, patchResults: PatchResult[]): string {
  const lines: string[] = [];
  lines.push("## Hydra Security Scan Results");
  lines.push("");
  lines.push(`**Target:** \`${scanResult.target.root_path}\``);
  lines.push(`**Mode:** ${scanResult.target.mode}`);
  lines.push(`**Findings:** ${scanResult.findings.length}`);
  lines.push("");

  if (patchResults.length > 0) {
    lines.push("## Patches");
    lines.push("");
    lines.push("| Finding | Severity | Status | Review |");
    lines.push("|---------|----------|--------|--------|");

    for (const pr of patchResults) {
      const f = pr.adversarial.finding;
      const statusEmoji = pr.status === "patched_and_verified" ? "pass" :
        pr.status === "patched_needs_review" ? "needs review" :
        pr.status === "patch_rejected" ? "rejected" : "skipped";
      const reviewNote = pr.review
        ? `${pr.review.issues.length} issue${pr.review.issues.length === 1 ? "" : "s"}`
        : "-";
      lines.push(`| ${f.title} | ${f.severity} | ${statusEmoji} | ${reviewNote} |`);
    }
    lines.push("");
  }

  if (patchResults.some((r) => r.patch?.patch_diff)) {
    lines.push("## Patch Diffs");
    lines.push("");
    for (const pr of patchResults) {
      if (!pr.patch?.patch_diff) continue;
      const f = pr.adversarial.finding;
      lines.push(`### ${f.title} (\`${f.file}:${f.line}\`)`);
      lines.push("");
      lines.push("```diff");
      lines.push(pr.patch.patch_diff);
      lines.push("```");
      lines.push("");
      if (pr.patch.explanation) {
        lines.push(`**Explanation:** ${pr.patch.explanation}`);
        lines.push("");
      }
    }
  }

  lines.push("---");
  lines.push("Generated by [Hydra Security](https://github.com/Pavelevich/hydra-security)");

  return lines.join("\n");
}

export async function createSecurityPr(
  scanResult: ScanResult,
  patchResults: PatchResult[],
  options: GitHubPrOptions
): Promise<{ prUrl?: string; branchName: string; dryRun: boolean }> {
  const baseBranch = options.baseBranch ?? "main";
  const prefix = options.branchPrefix ?? "hydra/security-fix";
  const timestamp = new Date().toISOString().replace(/[:.]/g, "-").slice(0, 19);
  const branchName = `${prefix}-${timestamp}`;

  const title = buildPrTitle(scanResult, patchResults);
  const body = buildPrBody(scanResult, patchResults);

  if (options.dryRun) {
    return { branchName, dryRun: true };
  }

  // Create branch
  const checkoutResult = await run("git", ["checkout", "-b", branchName], options.repoPath);
  if (checkoutResult.exitCode !== 0) {
    throw new Error(`Failed to create branch: ${checkoutResult.stderr}`);
  }

  // Stage all changes (patches should have been applied to working tree already)
  await run("git", ["add", "-A"], options.repoPath);

  // Commit
  const commitResult = await run(
    "git",
    ["commit", "-m", `fix: ${title}\n\nGenerated by Hydra Security automated patching pipeline.`],
    options.repoPath
  );

  if (commitResult.exitCode !== 0) {
    // Nothing to commit â€” restore branch
    await run("git", ["checkout", baseBranch], options.repoPath);
    await run("git", ["branch", "-D", branchName], options.repoPath);
    throw new Error(`Nothing to commit: ${commitResult.stderr}`);
  }

  // Push
  const pushResult = await run("git", ["push", "-u", "origin", branchName], options.repoPath);
  if (pushResult.exitCode !== 0) {
    throw new Error(`Failed to push branch: ${pushResult.stderr}`);
  }

  // Create PR via gh CLI
  const prResult = await run(
    "gh",
    ["pr", "create", "--title", title, "--body", body, "--base", baseBranch],
    options.repoPath,
    60_000
  );

  if (prResult.exitCode !== 0) {
    throw new Error(`Failed to create PR: ${prResult.stderr}`);
  }

  const prUrl = prResult.stdout.trim();

  // Return to base branch
  await run("git", ["checkout", baseBranch], options.repoPath);

  return { prUrl, branchName, dryRun: false };
}
