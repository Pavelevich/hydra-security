import { execFile } from "node:child_process";
import path from "node:path";
import type { ScanResult, Finding } from "../types";

interface ExecOutput {
  stdout: string;
  stderr: string;
  exitCode: number;
}

function runGh(args: string[], timeoutMs = 30_000): Promise<ExecOutput> {
  return new Promise((resolve) => {
    execFile("gh", args, { timeout: timeoutMs, maxBuffer: 5 * 1024 * 1024 }, (error, stdout, stderr) => {
      const exitCode = error && "code" in error ? (error.code as number) ?? 1 : 0;
      resolve({ stdout: stdout ?? "", stderr: stderr ?? "", exitCode });
    });
  });
}

function severityEmoji(severity: string): string {
  switch (severity) {
    case "CRITICAL": return "ðŸ”´";
    case "HIGH": return "ðŸŸ ";
    case "MEDIUM": return "ðŸŸ¡";
    case "LOW": return "ðŸ”µ";
    default: return "âšª";
  }
}

function buildInlineComment(finding: Finding): string {
  return [
    `${severityEmoji(finding.severity)} **${finding.severity}** â€” ${finding.title}`,
    "",
    `**Class:** \`${finding.vuln_class}\` | **Confidence:** ${finding.confidence}`,
    "",
    finding.description,
    "",
    `\`\`\``,
    finding.evidence,
    `\`\`\``,
  ].join("\n");
}

function buildSummaryComment(result: ScanResult): string {
  const critical = result.findings.filter((f) => f.severity === "CRITICAL").length;
  const high = result.findings.filter((f) => f.severity === "HIGH").length;
  const medium = result.findings.filter((f) => f.severity === "MEDIUM").length;
  const low = result.findings.filter((f) => f.severity === "LOW").length;

  const lines: string[] = [];
  lines.push("## Hydra Security Scan Results");
  lines.push("");
  lines.push(`**${result.findings.length}** finding${result.findings.length === 1 ? "" : "s"} detected`);
  lines.push("");

  if (result.findings.length > 0) {
    lines.push("| Severity | Count |");
    lines.push("|----------|-------|");
    if (critical > 0) lines.push(`| ${severityEmoji("CRITICAL")} CRITICAL | ${critical} |`);
    if (high > 0) lines.push(`| ${severityEmoji("HIGH")} HIGH | ${high} |`);
    if (medium > 0) lines.push(`| ${severityEmoji("MEDIUM")} MEDIUM | ${medium} |`);
    if (low > 0) lines.push(`| ${severityEmoji("LOW")} LOW | ${low} |`);
    lines.push("");

    lines.push("<details><summary>Finding Details</summary>");
    lines.push("");
    for (const finding of result.findings) {
      lines.push(`### ${severityEmoji(finding.severity)} ${finding.title}`);
      lines.push(`- **File:** \`${finding.file}:${finding.line}\``);
      lines.push(`- **Class:** \`${finding.vuln_class}\``);
      lines.push(`- **Confidence:** ${finding.confidence}`);
      lines.push(`- ${finding.description}`);
      lines.push("");
    }
    lines.push("</details>");
  } else {
    lines.push("No security issues found.");
  }

  lines.push("");
  lines.push("---");
  lines.push("*Generated by [Hydra Security](https://github.com/Pavelevich/hydra-security)*");

  return lines.join("\n");
}

export async function postPrReview(
  owner: string,
  repo: string,
  prNumber: number,
  commitSha: string,
  result: ScanResult
): Promise<void> {
  // Post summary comment
  const summary = buildSummaryComment(result);
  await runGh([
    "pr", "comment", String(prNumber),
    "--repo", `${owner}/${repo}`,
    "--body", summary
  ]);

  // Post inline review comments for each finding
  if (result.findings.length === 0) return;

  // Build review comments JSON for the GitHub API
  const comments = result.findings
    .filter((f) => f.file && f.line > 0)
    .map((finding) => ({
      path: finding.file.startsWith("/") ? path.relative(process.cwd(), finding.file) : finding.file,
      line: finding.line,
      body: buildInlineComment(finding)
    }));

  if (comments.length === 0) return;

  // Use gh api to create a pull request review with inline comments
  const reviewBody = JSON.stringify({
    commit_id: commitSha,
    body: `Hydra Security found ${result.findings.length} issue${result.findings.length === 1 ? "" : "s"}.`,
    event: "COMMENT",
    comments
  });

  await runGh([
    "api",
    "--method", "POST",
    `/repos/${owner}/${repo}/pulls/${prNumber}/reviews`,
    "--input", "-"
  ], 60_000).then(() => {
    // gh api --input - reads from stdin, but execFile doesn't support stdin easily.
    // Fall back to individual comments if the review API approach doesn't work.
  }).catch(() => {});

  // Fallback: post individual comments via gh api
  for (const comment of comments) {
    const commentBody = JSON.stringify({
      body: comment.body,
      commit_id: commitSha,
      path: comment.path,
      line: comment.line,
      side: "RIGHT"
    });

    await runGh([
      "api",
      "--method", "POST",
      `/repos/${owner}/${repo}/pulls/${prNumber}/comments`,
      "--field", `body=${comment.body}`,
      "--field", `commit_id=${commitSha}`,
      "--field", `path=${comment.path}`,
      "--field", `line=${String(comment.line)}`,
      "--field", `side=RIGHT`
    ]).catch(() => {
      // Individual comment may fail if file/line not in PR diff â€” that's OK
    });
  }
}

export async function postIssueComment(
  owner: string,
  repo: string,
  issueNumber: number,
  body: string
): Promise<void> {
  await runGh([
    "issue", "comment", String(issueNumber),
    "--repo", `${owner}/${repo}`,
    "--body", body
  ]);
}
